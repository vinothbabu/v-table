{"version":3,"sources":["./node_modules/@ngrx/store-devtools/fesm2015/store-devtools.js","./src/app/account/account/account.component.html","./src/app/common/v-table/v-table.component.html","./src/app/account/account.module.ts","./src/app/account/account/account.component.css","./src/app/account/account/account.component.ts","./src/app/account/state/account.reducers.ts","./src/app/account/state/reducer.ts","./src/app/common/v-table/v-table.component.css","./src/app/common/v-table/v-table.component.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAC2F;AACoE;AAC5E;AACkF;;AAErK;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA,WAAW,EAAE;AACb,kCAAkC,4DAAc;AAChD,WAAW,EAAE;AACb,4BAA4B,4DAAc;AAC1C;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA,WAAW;AACX;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB,mCAAmC,oBAAoB,WAAW;AAClE;AACA,wEAAwE,cAAc;AACtF;AACA;AACA;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AACA,iCAAiC,0DAAc;AAC/C;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,WAAW,oCAAoC;AAC/C;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA,KAAK,eAAe,EAAE,OAAO;AAC7B;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,2BAA2B,WAAW,oDAAoD;AAC1F;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,gBAAgB,qHAAqH;AAChK;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AACA,WAAW,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,qCAAqC,4DAAc;AACnD;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,yDAAyD,UAAU;AACnE;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,kDAAK;AACxB;AACA,mBAAmB,+CAAU;AAC7B,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,6DAA6D,4DAAK;AAClE;AACA,mBAAmB,EAAE;AACrB,qCAAqC,6DAAM;AAC3C,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oCAAoC,6DAAM;AAC1C,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,6CAA6C,6DAAM;AACnD,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,mEAAmE,0DAAG;AACtE,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,uDAAuD,gEAAS;AAChE,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAM;AAClD,2BAA2B,EAAE;AAC7B,4BAA4B;AAC5B;AACA,0CAA0C,kDAAM,IAAI,8DAAO,QAAQ,mEAAY,QAAQ,0DAAG;AAC1F,4BAA4B;AAC5B;AACA,gCAAgC,iEAAU;AAC1C,4BAA4B;AAC5B;AACA,sBAAsB,+CAAE,YAAY,2DAAI;AACxC;AACA;AACA,uBAAuB,+CAAE;AACzB;AACA,SAAS;AACT;AACA,mBAAmB,EAAE;AACrB,uCAAuC,6DAAM;AAC7C,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,iEAAiE,0DAAG;AACpE,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA,mBAAmB,EAAE;AACrB,gDAAgD,gEAAS;AACzD,mBAAmB,EAAE;AACrB,qDAAqD,gEAAS;AAC9D,kCAAkC,gEAAS;AAC3C;AACA,yCAAyC,gEAAS;AAClD,oBAAoB;AACpB;AACA;AACA,+CAA+C,gEAAS;AACxD,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;AACA;AACA;AACA,KAAK,gCAAgC,OAAO,oDAAM,qCAAqC,GAAG;AAC1F,KAAK,0CAA0C,OAAO,oDAAM,kCAAkC,GAAG;AACjG,KAAK;AACL;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AACA,WAAW,EAAE;AACb,qBAAqB,OAAO,gDAAI;AAChC,WAAW,EAAE;AACb,8BAA8B,EAAE;AAChC,WAAW,EAAE;AACb,0BAA0B;AAC1B;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA,0CAA0C,0BAA0B;AACpE,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA;AACA;AACA,kDAAkD;AAClD;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACA,8GAA8G;AAC9G;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA,aAAa,qJAAqJ;AAClK;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,EAAE;AACzB;AACA,uBAAuB,EAAE;AACzB;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,EAAE;AACzB,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C,2BAA2B,EAAE;AAC7B;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB,gDAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAM;AACvB,2BAA2B,EAAE;AAC7B;AACA,2BAA2B,EAAE;AAC7B,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE;AACjC,gCAAgC;AAChC;AACA,4CAA4C,QAAQ,8CAA8C;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB;AACA,mBAAmB,EAAE;AACrB,8BAA8B,kDAAK,CAAC,kDAAK,8BAA8B,2DAAI,+BAA+B,0DAAG,0DAA0D,gEAAS,CAAC,mDAAc;AAC/L,mBAAmB,EAAE;AACrB,8CAA8C,0DAAG;AACjD,mBAAmB,EAAE;AACrB,uCAAuC,kDAAa;AACpD,mBAAmB,EAAE;AACrB;AACA,kBAAkB,qEAAc,kBAAkB,2DAAI;AACtD,mBAAmB,EAAE;AACrB,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,UAAU,qBAAqB;AAC/B,uBAAuB,EAAE;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS,IAAI,gDAAgD,EAAE,aAAa;AAC5E;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA,2BAA2B,EAAE;AAC7B,oDAAoD,EAAE;AACtD;AACA;AACA,SAAS;AACT,mBAAmB,EAAE;AACrB;AACA,oBAAoB;AACpB;AACA;AACA;AACA,SAAS;AACT,mBAAmB,EAAE;AACrB,yCAAyC,EAAE;AAC3C,mBAAmB,EAAE;AACrB,yCAAyC,0DAAG;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA,kBAAkB;AAClB;AACA,gBAAgB;AAChB;AACA,gBAAgB;AAChB;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU;AACtB;AACA;AACA;AACA,KAAK,2BAA2B;AAChC,KAAK,OAAO,0DAAc,EAAE;AAC5B,KAAK,OAAO,6DAAiB,EAAE;AAC/B,KAAK,0BAA0B;AAC/B,KAAK,OAAO,iEAAqB,EAAE;AACnC,KAAK,OAAO,0DAAY,EAAE;AAC1B,KAAK,gCAAgC,OAAO,oDAAM,SAAS,yDAAa,IAAI,GAAG;AAC/E,KAAK,0CAA0C,OAAO,oDAAM,kCAAkC;AAC9F;;AAEA;AACA;AACA,cAAc,uFAAuF;AACrG;AAC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","file":"account-account-module-es2015.js","sourcesContent":["/**\n * @license NgRx 8.6.0\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\nimport { InjectionToken, Injectable, Inject, ErrorHandler, NgModule } from '@angular/core';\nimport { ActionsSubject, UPDATE, INIT, ReducerObservable, ScannedActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { empty, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass StoreDevtoolsConfig {\n}\n/** @type {?} */\nconst STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/devtools Options');\n/** @type {?} */\nconst INITIAL_OPTIONS = new InjectionToken('@ngrx/devtools Initial Config');\n/**\n * @return {?}\n */\nfunction noMonitor() {\n    return null;\n}\n/** @type {?} */\nconst DEFAULT_NAME = 'NgRx Store DevTools';\n/**\n * @param {?} _options\n * @return {?}\n */\nfunction createConfig(_options) {\n    /** @type {?} */\n    const DEFAULT_OPTIONS = {\n        maxAge: false,\n        monitor: noMonitor,\n        actionSanitizer: undefined,\n        stateSanitizer: undefined,\n        name: DEFAULT_NAME,\n        serialize: false,\n        logOnly: false,\n        // Add all features explicitly. This prevent buggy behavior for\n        // options like \"lock\" which might otherwise not show up.\n        features: {\n            pause: true,\n            // start/pause recording of dispatched actions\n            lock: true,\n            // lock/unlock dispatching actions and side effects\n            persist: true,\n            // persist states on page reloading\n            export: true,\n            // export history of actions in a file\n            import: 'custom',\n            // import history of actions from a file\n            jump: true,\n            // jump back and forth (time travelling)\n            skip: true,\n            // skip (cancel) actions\n            reorder: true,\n            // drag and drop actions in the history list\n            dispatch: true,\n            // dispatch custom actions or action creators\n            test: true,\n        },\n    };\n    /** @type {?} */\n    let options = typeof _options === 'function' ? _options() : _options;\n    /** @type {?} */\n    const logOnly = options.logOnly\n        ? { pause: true, export: true, test: true }\n        : false;\n    /** @type {?} */\n    const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n    /** @type {?} */\n    const config = Object.assign({}, DEFAULT_OPTIONS, { features }, options);\n    if (config.maxAge && config.maxAge < 2) {\n        throw new Error(`Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`);\n    }\n    return config;\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst PERFORM_ACTION = 'PERFORM_ACTION';\n/** @type {?} */\nconst REFRESH = 'REFRESH';\n/** @type {?} */\nconst RESET = 'RESET';\n/** @type {?} */\nconst ROLLBACK = 'ROLLBACK';\n/** @type {?} */\nconst COMMIT = 'COMMIT';\n/** @type {?} */\nconst SWEEP = 'SWEEP';\n/** @type {?} */\nconst TOGGLE_ACTION = 'TOGGLE_ACTION';\n/** @type {?} */\nconst SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\n/** @type {?} */\nconst JUMP_TO_STATE = 'JUMP_TO_STATE';\n/** @type {?} */\nconst JUMP_TO_ACTION = 'JUMP_TO_ACTION';\n/** @type {?} */\nconst IMPORT_STATE = 'IMPORT_STATE';\n/** @type {?} */\nconst LOCK_CHANGES = 'LOCK_CHANGES';\n/** @type {?} */\nconst PAUSE_RECORDING = 'PAUSE_RECORDING';\nclass PerformAction {\n    /**\n     * @param {?} action\n     * @param {?} timestamp\n     */\n    constructor(action, timestamp) {\n        this.action = action;\n        this.timestamp = timestamp;\n        this.type = PERFORM_ACTION;\n        if (typeof action.type === 'undefined') {\n            throw new Error('Actions may not have an undefined \"type\" property. ' +\n                'Have you misspelled a constant?');\n        }\n    }\n}\nclass Refresh {\n    constructor() {\n        this.type = REFRESH;\n    }\n}\nclass Reset {\n    /**\n     * @param {?} timestamp\n     */\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = RESET;\n    }\n}\nclass Rollback {\n    /**\n     * @param {?} timestamp\n     */\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = ROLLBACK;\n    }\n}\nclass Commit {\n    /**\n     * @param {?} timestamp\n     */\n    constructor(timestamp) {\n        this.timestamp = timestamp;\n        this.type = COMMIT;\n    }\n}\nclass Sweep {\n    constructor() {\n        this.type = SWEEP;\n    }\n}\nclass ToggleAction {\n    /**\n     * @param {?} id\n     */\n    constructor(id) {\n        this.id = id;\n        this.type = TOGGLE_ACTION;\n    }\n}\nclass JumpToState {\n    /**\n     * @param {?} index\n     */\n    constructor(index) {\n        this.index = index;\n        this.type = JUMP_TO_STATE;\n    }\n}\nclass JumpToAction {\n    /**\n     * @param {?} actionId\n     */\n    constructor(actionId) {\n        this.actionId = actionId;\n        this.type = JUMP_TO_ACTION;\n    }\n}\nclass ImportState {\n    /**\n     * @param {?} nextLiftedState\n     */\n    constructor(nextLiftedState) {\n        this.nextLiftedState = nextLiftedState;\n        this.type = IMPORT_STATE;\n    }\n}\nclass LockChanges {\n    /**\n     * @param {?} status\n     */\n    constructor(status) {\n        this.status = status;\n        this.type = LOCK_CHANGES;\n    }\n}\nclass PauseRecording {\n    /**\n     * @param {?} status\n     */\n    constructor(status) {\n        this.status = status;\n        this.type = PAUSE_RECORDING;\n    }\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass DevtoolsDispatcher extends ActionsSubject {\n}\nDevtoolsDispatcher.decorators = [\n    { type: Injectable }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * @param {?} first\n * @param {?} second\n * @return {?}\n */\nfunction difference(first, second) {\n    return first.filter((/**\n     * @param {?} item\n     * @return {?}\n     */\n    item => second.indexOf(item) < 0));\n}\n/**\n * Provides an app's view into the state of the lifted store.\n * @param {?} liftedState\n * @return {?}\n */\nfunction unliftState(liftedState) {\n    const { computedStates, currentStateIndex } = liftedState;\n    // At start up NgRx dispatches init actions,\n    // When these init actions are being filtered out by the predicate or safe/block list options\n    // we don't have a complete computed states yet.\n    // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n    if (currentStateIndex >= computedStates.length) {\n        const { state } = computedStates[computedStates.length - 1];\n        return state;\n    }\n    const { state } = computedStates[currentStateIndex];\n    return state;\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n * @param {?} action\n * @return {?}\n */\nfunction liftAction(action) {\n    return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n * @param {?} actionSanitizer\n * @param {?} actions\n * @return {?}\n */\nfunction sanitizeActions(actionSanitizer, actions) {\n    return Object.keys(actions).reduce((/**\n     * @param {?} sanitizedActions\n     * @param {?} actionIdx\n     * @return {?}\n     */\n    (sanitizedActions, actionIdx) => {\n        /** @type {?} */\n        const idx = Number(actionIdx);\n        sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n        return sanitizedActions;\n    }), (/** @type {?} */ ({})));\n}\n/**\n * Sanitizes given action with given function.\n * @param {?} actionSanitizer\n * @param {?} action\n * @param {?} actionIdx\n * @return {?}\n */\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n    return Object.assign({}, action, { action: actionSanitizer(action.action, actionIdx) });\n}\n/**\n * Sanitizes given states with given function.\n * @param {?} stateSanitizer\n * @param {?} states\n * @return {?}\n */\nfunction sanitizeStates(stateSanitizer, states) {\n    return states.map((/**\n     * @param {?} computedState\n     * @param {?} idx\n     * @return {?}\n     */\n    (computedState, idx) => ({\n        state: sanitizeState(stateSanitizer, computedState.state, idx),\n        error: computedState.error,\n    })));\n}\n/**\n * Sanitizes given state with given function.\n * @param {?} stateSanitizer\n * @param {?} state\n * @param {?} stateIdx\n * @return {?}\n */\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n    return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n * @param {?} config\n * @return {?}\n */\nfunction shouldFilterActions(config) {\n    return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n * @param {?} liftedState\n * @param {?=} predicate\n * @param {?=} safelist\n * @param {?=} blocklist\n * @return {?}\n */\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n    /** @type {?} */\n    const filteredStagedActionIds = [];\n    /** @type {?} */\n    const filteredActionsById = {};\n    /** @type {?} */\n    const filteredComputedStates = [];\n    liftedState.stagedActionIds.forEach((/**\n     * @param {?} id\n     * @param {?} idx\n     * @return {?}\n     */\n    (id, idx) => {\n        /** @type {?} */\n        const liftedAction = liftedState.actionsById[id];\n        if (!liftedAction)\n            return;\n        if (idx &&\n            isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n            return;\n        }\n        filteredActionsById[id] = liftedAction;\n        filteredStagedActionIds.push(id);\n        filteredComputedStates.push(liftedState.computedStates[idx]);\n    }));\n    return Object.assign({}, liftedState, { stagedActionIds: filteredStagedActionIds, actionsById: filteredActionsById, computedStates: filteredComputedStates });\n}\n/**\n * Return true is the action should be ignored\n * @param {?} state\n * @param {?} action\n * @param {?=} predicate\n * @param {?=} safelist\n * @param {?=} blockedlist\n * @return {?}\n */\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n    /** @type {?} */\n    const predicateMatch = predicate && !predicate(state, action.action);\n    /** @type {?} */\n    const safelistMatch = safelist &&\n        !action.action.type.match(safelist.map((/**\n         * @param {?} s\n         * @return {?}\n         */\n        s => escapeRegExp(s))).join('|'));\n    /** @type {?} */\n    const blocklistMatch = blockedlist &&\n        action.action.type.match(blockedlist.map((/**\n         * @param {?} s\n         * @return {?}\n         */\n        s => escapeRegExp(s))).join('|'));\n    return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n * @param {?} s\n * @return {?}\n */\nfunction escapeRegExp(s) {\n    return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ExtensionActionTypes = {\n    START: 'START',\n    DISPATCH: 'DISPATCH',\n    STOP: 'STOP',\n    ACTION: 'ACTION',\n};\n/** @type {?} */\nconst REDUX_DEVTOOLS_EXTENSION = new InjectionToken('Redux Devtools Extension');\nclass DevtoolsExtension {\n    /**\n     * @param {?} devtoolsExtension\n     * @param {?} config\n     * @param {?} dispatcher\n     */\n    constructor(devtoolsExtension, config, dispatcher) {\n        this.config = config;\n        this.dispatcher = dispatcher;\n        this.devtoolsExtension = devtoolsExtension;\n        this.createActionStreams();\n    }\n    /**\n     * @param {?} action\n     * @param {?} state\n     * @return {?}\n     */\n    notify(action, state) {\n        if (!this.devtoolsExtension) {\n            return;\n        }\n        // Check to see if the action requires a full update of the liftedState.\n        // If it is a simple action generated by the user's app and the recording\n        // is not locked/paused, only send the action and the current state (fast).\n        //\n        // A full liftedState update (slow: serializes the entire liftedState) is\n        // only required when:\n        //   a) redux-devtools-extension fires the @@Init action (ignored by\n        //      @ngrx/store-devtools)\n        //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n        //      or @ngrx/store/update-reducers)\n        //   c) the state has been recomputed due to time-traveling\n        //   d) any action that is not a PerformAction to err on the side of\n        //      caution.\n        if (action.type === PERFORM_ACTION) {\n            if (state.isLocked || state.isPaused) {\n                return;\n            }\n            /** @type {?} */\n            const currentState = unliftState(state);\n            if (shouldFilterActions(this.config) &&\n                isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n                return;\n            }\n            /** @type {?} */\n            const sanitizedState = this.config.stateSanitizer\n                ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex)\n                : currentState;\n            /** @type {?} */\n            const sanitizedAction = this.config.actionSanitizer\n                ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId)\n                : action;\n            this.sendToReduxDevtools((/**\n             * @return {?}\n             */\n            () => this.extensionConnection.send(sanitizedAction, sanitizedState)));\n        }\n        else {\n            // Requires full state update\n            /** @type {?} */\n            const sanitizedLiftedState = Object.assign({}, state, { stagedActionIds: state.stagedActionIds, actionsById: this.config.actionSanitizer\n                    ? sanitizeActions(this.config.actionSanitizer, state.actionsById)\n                    : state.actionsById, computedStates: this.config.stateSanitizer\n                    ? sanitizeStates(this.config.stateSanitizer, state.computedStates)\n                    : state.computedStates });\n            this.sendToReduxDevtools((/**\n             * @return {?}\n             */\n            () => this.devtoolsExtension.send(null, sanitizedLiftedState, this.getExtensionConfig(this.config))));\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    createChangesObservable() {\n        if (!this.devtoolsExtension) {\n            return empty();\n        }\n        return new Observable((/**\n         * @param {?} subscriber\n         * @return {?}\n         */\n        subscriber => {\n            /** @type {?} */\n            const connection = this.devtoolsExtension.connect(this.getExtensionConfig(this.config));\n            this.extensionConnection = connection;\n            connection.init();\n            connection.subscribe((/**\n             * @param {?} change\n             * @return {?}\n             */\n            (change) => subscriber.next(change)));\n            return connection.unsubscribe;\n        }));\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    createActionStreams() {\n        // Listens to all changes\n        /** @type {?} */\n        const changes$ = this.createChangesObservable().pipe(share());\n        // Listen for the start action\n        /** @type {?} */\n        const start$ = changes$.pipe(filter((/**\n         * @param {?} change\n         * @return {?}\n         */\n        (change) => change.type === ExtensionActionTypes.START)));\n        // Listen for the stop action\n        /** @type {?} */\n        const stop$ = changes$.pipe(filter((/**\n         * @param {?} change\n         * @return {?}\n         */\n        (change) => change.type === ExtensionActionTypes.STOP)));\n        // Listen for lifted actions\n        /** @type {?} */\n        const liftedActions$ = changes$.pipe(filter((/**\n         * @param {?} change\n         * @return {?}\n         */\n        change => change.type === ExtensionActionTypes.DISPATCH)), map((/**\n         * @param {?} change\n         * @return {?}\n         */\n        change => this.unwrapAction(change.payload))), concatMap((/**\n         * @param {?} action\n         * @return {?}\n         */\n        (action) => {\n            if (action.type === IMPORT_STATE) {\n                // State imports may happen in two situations:\n                // 1. Explicitly by user\n                // 2. User activated the \"persist state accross reloads\" option\n                //    and now the state is imported during reload.\n                // Because of option 2, we need to give possible\n                // lazy loaded reducers time to instantiate.\n                // As soon as there is no UPDATE action within 1 second,\n                // it is assumed that all reducers are loaded.\n                return this.dispatcher.pipe(filter((/**\n                 * @param {?} action\n                 * @return {?}\n                 */\n                action => action.type === UPDATE)), timeout(1000), debounceTime(1000), map((/**\n                 * @return {?}\n                 */\n                () => action)), catchError((/**\n                 * @return {?}\n                 */\n                () => of(action))), take(1));\n            }\n            else {\n                return of(action);\n            }\n        })));\n        // Listen for unlifted actions\n        /** @type {?} */\n        const actions$ = changes$.pipe(filter((/**\n         * @param {?} change\n         * @return {?}\n         */\n        change => change.type === ExtensionActionTypes.ACTION)), map((/**\n         * @param {?} change\n         * @return {?}\n         */\n        change => this.unwrapAction(change.payload))));\n        /** @type {?} */\n        const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n        /** @type {?} */\n        const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n        this.start$ = start$.pipe(takeUntil(stop$));\n        // Only take the action sources between the start/stop events\n        this.actions$ = this.start$.pipe(switchMap((/**\n         * @return {?}\n         */\n        () => actionsUntilStop$)));\n        this.liftedActions$ = this.start$.pipe(switchMap((/**\n         * @return {?}\n         */\n        () => liftedUntilStop$)));\n    }\n    /**\n     * @private\n     * @param {?} action\n     * @return {?}\n     */\n    unwrapAction(action) {\n        return typeof action === 'string' ? eval(`(${action})`) : action;\n    }\n    /**\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n    getExtensionConfig(config) {\n        /** @type {?} */\n        const extensionOptions = {\n            name: config.name,\n            features: config.features,\n            serialize: config.serialize,\n        };\n        if (config.maxAge !== false /* support === 0 */) {\n            extensionOptions.maxAge = config.maxAge;\n        }\n        return extensionOptions;\n    }\n    /**\n     * @private\n     * @param {?} send\n     * @return {?}\n     */\n    sendToReduxDevtools(send) {\n        try {\n            send();\n        }\n        catch (err) {\n            console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n        }\n    }\n}\nDevtoolsExtension.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nDevtoolsExtension.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [REDUX_DEVTOOLS_EXTENSION,] }] },\n    { type: StoreDevtoolsConfig, decorators: [{ type: Inject, args: [STORE_DEVTOOLS_CONFIG,] }] },\n    { type: DevtoolsDispatcher }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst INIT_ACTION = { type: INIT };\n/** @type {?} */\nconst RECOMPUTE = (/** @type {?} */ ('@ngrx/store-devtools/recompute'));\n/** @type {?} */\nconst RECOMPUTE_ACTION = { type: RECOMPUTE };\n/**\n * Computes the next entry in the log by applying an action.\n * @param {?} reducer\n * @param {?} action\n * @param {?} state\n * @param {?} error\n * @param {?} errorHandler\n * @return {?}\n */\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n    if (error) {\n        return {\n            state,\n            error: 'Interrupted by an error up the chain',\n        };\n    }\n    /** @type {?} */\n    let nextState = state;\n    /** @type {?} */\n    let nextError;\n    try {\n        nextState = reducer(state, action);\n    }\n    catch (err) {\n        nextError = err.toString();\n        errorHandler.handleError(err.stack || err);\n    }\n    return {\n        state: nextState,\n        error: nextError,\n    };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n * @param {?} computedStates\n * @param {?} minInvalidatedStateIndex\n * @param {?} reducer\n * @param {?} committedState\n * @param {?} actionsById\n * @param {?} stagedActionIds\n * @param {?} skippedActionIds\n * @param {?} errorHandler\n * @param {?} isPaused\n * @return {?}\n */\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n    // Optimization: exit early and return the same reference\n    // if we know nothing could have changed.\n    if (minInvalidatedStateIndex >= computedStates.length &&\n        computedStates.length === stagedActionIds.length) {\n        return computedStates;\n    }\n    /** @type {?} */\n    const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n    // If the recording is paused, recompute all states up until the pause state,\n    // else recompute all states.\n    /** @type {?} */\n    const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n    for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n        /** @type {?} */\n        const actionId = stagedActionIds[i];\n        /** @type {?} */\n        const action = actionsById[actionId].action;\n        /** @type {?} */\n        const previousEntry = nextComputedStates[i - 1];\n        /** @type {?} */\n        const previousState = previousEntry ? previousEntry.state : committedState;\n        /** @type {?} */\n        const previousError = previousEntry ? previousEntry.error : undefined;\n        /** @type {?} */\n        const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n        /** @type {?} */\n        const entry = shouldSkip\n            ? previousEntry\n            : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n        nextComputedStates.push(entry);\n    }\n    // If the recording is paused, the last state will not be recomputed,\n    // because it's essentially not part of the state history.\n    if (isPaused) {\n        nextComputedStates.push(computedStates[computedStates.length - 1]);\n    }\n    return nextComputedStates;\n}\n/**\n * @param {?=} initialCommittedState\n * @param {?=} monitorReducer\n * @return {?}\n */\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n    return {\n        monitorState: monitorReducer(undefined, {}),\n        nextActionId: 1,\n        actionsById: { 0: liftAction(INIT_ACTION) },\n        stagedActionIds: [0],\n        skippedActionIds: [],\n        committedState: initialCommittedState,\n        currentStateIndex: 0,\n        computedStates: [],\n        isLocked: false,\n        isPaused: false,\n    };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n * @param {?} initialCommittedState\n * @param {?} initialLiftedState\n * @param {?} errorHandler\n * @param {?=} monitorReducer\n * @param {?=} options\n * @return {?}\n */\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer, options = {}) {\n    /**\n     * Manages how the history actions modify the history state.\n     */\n    return (/**\n     * @param {?} reducer\n     * @return {?}\n     */\n    (reducer) => (/**\n     * @param {?} liftedState\n     * @param {?} liftedAction\n     * @return {?}\n     */\n    (liftedState, liftedAction) => {\n        let { monitorState, actionsById, nextActionId, stagedActionIds, skippedActionIds, committedState, currentStateIndex, computedStates, isLocked, isPaused, } = liftedState || initialLiftedState;\n        if (!liftedState) {\n            // Prevent mutating initialLiftedState\n            actionsById = Object.create(actionsById);\n        }\n        /**\n         * @param {?} n\n         * @return {?}\n         */\n        function commitExcessActions(n) {\n            // Auto-commits n-number of excess actions.\n            /** @type {?} */\n            let excess = n;\n            /** @type {?} */\n            let idsToDelete = stagedActionIds.slice(1, excess + 1);\n            for (let i = 0; i < idsToDelete.length; i++) {\n                if (computedStates[i + 1].error) {\n                    // Stop if error is found. Commit actions up to error.\n                    excess = i;\n                    idsToDelete = stagedActionIds.slice(1, excess + 1);\n                    break;\n                }\n                else {\n                    delete actionsById[idsToDelete[i]];\n                }\n            }\n            skippedActionIds = skippedActionIds.filter((/**\n             * @param {?} id\n             * @return {?}\n             */\n            id => idsToDelete.indexOf(id) === -1));\n            stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n            committedState = computedStates[excess].state;\n            computedStates = computedStates.slice(excess);\n            currentStateIndex =\n                currentStateIndex > excess ? currentStateIndex - excess : 0;\n        }\n        /**\n         * @return {?}\n         */\n        function commitChanges() {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = { 0: liftAction(INIT_ACTION) };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n        }\n        // By default, aggressively recompute every state whatever happens.\n        // This has O(n) performance, so we'll override this to a sensible\n        // value whenever we feel like we don't have to recompute the states.\n        /** @type {?} */\n        let minInvalidatedStateIndex = 0;\n        switch (liftedAction.type) {\n            case LOCK_CHANGES: {\n                isLocked = liftedAction.status;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case PAUSE_RECORDING: {\n                isPaused = liftedAction.status;\n                if (isPaused) {\n                    // Add a pause action to signal the devtools-user the recording is paused.\n                    // The corresponding state will be overwritten on each update to always contain\n                    // the latest state (see Actions.PERFORM_ACTION).\n                    stagedActionIds = [...stagedActionIds, nextActionId];\n                    actionsById[nextActionId] = new PerformAction({\n                        type: '@ngrx/devtools/pause',\n                    }, +Date.now());\n                    nextActionId++;\n                    minInvalidatedStateIndex = stagedActionIds.length - 1;\n                    computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n                    if (currentStateIndex === stagedActionIds.length - 2) {\n                        currentStateIndex++;\n                    }\n                    minInvalidatedStateIndex = Infinity;\n                }\n                else {\n                    commitChanges();\n                }\n                break;\n            }\n            case RESET: {\n                // Get back to the state the store was created with.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                committedState = initialCommittedState;\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case COMMIT: {\n                commitChanges();\n                break;\n            }\n            case ROLLBACK: {\n                // Forget about any staged actions.\n                // Start again from the last committed state.\n                actionsById = { 0: liftAction(INIT_ACTION) };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n            }\n            case TOGGLE_ACTION: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                const { id: actionId } = liftedAction;\n                /** @type {?} */\n                const index = skippedActionIds.indexOf(actionId);\n                if (index === -1) {\n                    skippedActionIds = [actionId, ...skippedActionIds];\n                }\n                else {\n                    skippedActionIds = skippedActionIds.filter((/**\n                     * @param {?} id\n                     * @return {?}\n                     */\n                    id => id !== actionId));\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n                break;\n            }\n            case SET_ACTIONS_ACTIVE: {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                const { start, end, active } = liftedAction;\n                /** @type {?} */\n                const actionIds = [];\n                for (let i = start; i < end; i++)\n                    actionIds.push(i);\n                if (active) {\n                    skippedActionIds = difference(skippedActionIds, actionIds);\n                }\n                else {\n                    skippedActionIds = [...skippedActionIds, ...actionIds];\n                }\n                // Optimization: we know history before this action hasn't changed\n                minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n                break;\n            }\n            case JUMP_TO_STATE: {\n                // Without recomputing anything, move the pointer that tell us\n                // which state is considered the current one. Useful for sliders.\n                currentStateIndex = liftedAction.index;\n                // Optimization: we know the history has not changed.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case JUMP_TO_ACTION: {\n                // Jumps to a corresponding state to a specific action.\n                // Useful when filtering actions.\n                /** @type {?} */\n                const index = stagedActionIds.indexOf(liftedAction.actionId);\n                if (index !== -1)\n                    currentStateIndex = index;\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n            case SWEEP: {\n                // Forget any actions that are currently being skipped.\n                stagedActionIds = difference(stagedActionIds, skippedActionIds);\n                skippedActionIds = [];\n                currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n                break;\n            }\n            case PERFORM_ACTION: {\n                // Ignore action and return state as is if recording is locked\n                if (isLocked) {\n                    return liftedState || initialLiftedState;\n                }\n                if (isPaused ||\n                    (liftedState &&\n                        isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist))) {\n                    // If recording is paused or if the action should be ignored, overwrite the last state\n                    // (corresponds to the pause action) and keep everything else as is.\n                    // This way, the app gets the new current state while the devtools\n                    // do not record another action.\n                    /** @type {?} */\n                    const lastState = computedStates[computedStates.length - 1];\n                    computedStates = [\n                        ...computedStates.slice(0, -1),\n                        computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler),\n                    ];\n                    minInvalidatedStateIndex = Infinity;\n                    break;\n                }\n                // Auto-commit as new actions come in.\n                if (options.maxAge && stagedActionIds.length === options.maxAge) {\n                    commitExcessActions(1);\n                }\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                    currentStateIndex++;\n                }\n                /** @type {?} */\n                const actionId = nextActionId++;\n                // Mutation! This is the hottest path, and we optimize on purpose.\n                // It is safe because we set a new key in a cache dictionary.\n                actionsById[actionId] = liftedAction;\n                stagedActionIds = [...stagedActionIds, actionId];\n                // Optimization: we know that only the new action needs computing.\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                break;\n            }\n            case IMPORT_STATE: {\n                // Completely replace everything.\n                ({\n                    monitorState,\n                    actionsById,\n                    nextActionId,\n                    stagedActionIds,\n                    skippedActionIds,\n                    committedState,\n                    currentStateIndex,\n                    computedStates,\n                    isLocked,\n                    // prettier-ignore\n                    isPaused\n                } = liftedAction.nextLiftedState);\n                break;\n            }\n            case INIT: {\n                // Always recompute states on hot reload and init.\n                minInvalidatedStateIndex = 0;\n                if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                    // States must be recomputed before committing excess.\n                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    commitExcessActions(stagedActionIds.length - options.maxAge);\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            case UPDATE: {\n                /** @type {?} */\n                const stateHasErrors = computedStates.filter((/**\n                 * @param {?} state\n                 * @return {?}\n                 */\n                state => state.error)).length > 0;\n                if (stateHasErrors) {\n                    // Recompute all states\n                    minInvalidatedStateIndex = 0;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        // States must be recomputed before committing excess.\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                        // Avoid double computation.\n                        minInvalidatedStateIndex = Infinity;\n                    }\n                }\n                else {\n                    // If not paused/locked, add a new action to signal devtools-user\n                    // that there was a reducer update.\n                    if (!isPaused && !isLocked) {\n                        if (currentStateIndex === stagedActionIds.length - 1) {\n                            currentStateIndex++;\n                        }\n                        // Add a new action to only recompute state\n                        /** @type {?} */\n                        const actionId = nextActionId++;\n                        actionsById[actionId] = new PerformAction(liftedAction, +Date.now());\n                        stagedActionIds = [...stagedActionIds, actionId];\n                        minInvalidatedStateIndex = stagedActionIds.length - 1;\n                        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    }\n                    // Recompute state history with latest reducer and update action\n                    computedStates = computedStates.map((/**\n                     * @param {?} cmp\n                     * @return {?}\n                     */\n                    cmp => (Object.assign({}, cmp, { state: reducer(cmp.state, RECOMPUTE_ACTION) }))));\n                    currentStateIndex = stagedActionIds.length - 1;\n                    if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                        commitExcessActions(stagedActionIds.length - options.maxAge);\n                    }\n                    // Avoid double computation.\n                    minInvalidatedStateIndex = Infinity;\n                }\n                break;\n            }\n            default: {\n                // If the action is not recognized, it's a monitor action.\n                // Optimization: a monitor action can't change history.\n                minInvalidatedStateIndex = Infinity;\n                break;\n            }\n        }\n        computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n        monitorState = monitorReducer(monitorState, liftedAction);\n        return {\n            monitorState,\n            actionsById,\n            nextActionId,\n            stagedActionIds,\n            skippedActionIds,\n            committedState,\n            currentStateIndex,\n            computedStates,\n            isLocked,\n            isPaused,\n        };\n    }));\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass StoreDevtools {\n    /**\n     * @param {?} dispatcher\n     * @param {?} actions$\n     * @param {?} reducers$\n     * @param {?} extension\n     * @param {?} scannedActions\n     * @param {?} errorHandler\n     * @param {?} initialState\n     * @param {?} config\n     */\n    constructor(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n        /** @type {?} */\n        const liftedInitialState = liftInitialState(initialState, config.monitor);\n        /** @type {?} */\n        const liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n        /** @type {?} */\n        const liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n        /** @type {?} */\n        const liftedReducer$ = reducers$.pipe(map(liftReducer));\n        /** @type {?} */\n        const liftedStateSubject = new ReplaySubject(1);\n        /** @type {?} */\n        const liftedStateSubscription = liftedAction$\n            .pipe(withLatestFrom(liftedReducer$), scan((/**\n         * @param {?} __0\n         * @param {?} __1\n         * @return {?}\n         */\n        ({ state: liftedState }, [action, reducer]) => {\n            /** @type {?} */\n            let reducedLiftedState = reducer(liftedState, action);\n            // On full state update\n            // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n            if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n                reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n            }\n            // Extension should be sent the sanitized lifted state\n            extension.notify(action, reducedLiftedState);\n            return { state: reducedLiftedState, action };\n        }), { state: liftedInitialState, action: (/** @type {?} */ (null)) }))\n            .subscribe((/**\n         * @param {?} __0\n         * @return {?}\n         */\n        ({ state, action }) => {\n            liftedStateSubject.next(state);\n            if (action.type === PERFORM_ACTION) {\n                /** @type {?} */\n                const unliftedAction = ((/** @type {?} */ (action))).action;\n                scannedActions.next(unliftedAction);\n            }\n        }));\n        /** @type {?} */\n        const extensionStartSubscription = extension.start$.subscribe((/**\n         * @return {?}\n         */\n        () => {\n            this.refresh();\n        }));\n        /** @type {?} */\n        const liftedState$ = (/** @type {?} */ (liftedStateSubject.asObservable()));\n        /** @type {?} */\n        const state$ = liftedState$.pipe(map(unliftState));\n        this.extensionStartSubscription = extensionStartSubscription;\n        this.stateSubscription = liftedStateSubscription;\n        this.dispatcher = dispatcher;\n        this.liftedState = liftedState$;\n        this.state = state$;\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    dispatch(action) {\n        this.dispatcher.next(action);\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    next(action) {\n        this.dispatcher.next(action);\n    }\n    /**\n     * @param {?} error\n     * @return {?}\n     */\n    error(error) { }\n    /**\n     * @return {?}\n     */\n    complete() { }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n    performAction(action) {\n        this.dispatch(new PerformAction(action, +Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n    refresh() {\n        this.dispatch(new Refresh());\n    }\n    /**\n     * @return {?}\n     */\n    reset() {\n        this.dispatch(new Reset(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n    rollback() {\n        this.dispatch(new Rollback(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n    commit() {\n        this.dispatch(new Commit(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n    sweep() {\n        this.dispatch(new Sweep());\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n    toggleAction(id) {\n        this.dispatch(new ToggleAction(id));\n    }\n    /**\n     * @param {?} actionId\n     * @return {?}\n     */\n    jumpToAction(actionId) {\n        this.dispatch(new JumpToAction(actionId));\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n    jumpToState(index) {\n        this.dispatch(new JumpToState(index));\n    }\n    /**\n     * @param {?} nextLiftedState\n     * @return {?}\n     */\n    importState(nextLiftedState) {\n        this.dispatch(new ImportState(nextLiftedState));\n    }\n    /**\n     * @param {?} status\n     * @return {?}\n     */\n    lockChanges(status) {\n        this.dispatch(new LockChanges(status));\n    }\n    /**\n     * @param {?} status\n     * @return {?}\n     */\n    pauseRecording(status) {\n        this.dispatch(new PauseRecording(status));\n    }\n}\nStoreDevtools.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nStoreDevtools.ctorParameters = () => [\n    { type: DevtoolsDispatcher },\n    { type: ActionsSubject },\n    { type: ReducerObservable },\n    { type: DevtoolsExtension },\n    { type: ScannedActionsSubject },\n    { type: ErrorHandler },\n    { type: undefined, decorators: [{ type: Inject, args: [INITIAL_STATE,] }] },\n    { type: StoreDevtoolsConfig, decorators: [{ type: Inject, args: [STORE_DEVTOOLS_CONFIG,] }] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('Is Devtools Extension or Monitor Present');\n/**\n * @param {?} extension\n * @param {?} config\n * @return {?}\n */\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n    return Boolean(extension) || config.monitor !== noMonitor;\n}\n/**\n * @return {?}\n */\nfunction createReduxDevtoolsExtension() {\n    /** @type {?} */\n    const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n    if (typeof window === 'object' &&\n        typeof ((/** @type {?} */ (window)))[extensionKey] !== 'undefined') {\n        return ((/** @type {?} */ (window)))[extensionKey];\n    }\n    else {\n        return null;\n    }\n}\n/**\n * @param {?} devtools\n * @return {?}\n */\nfunction createStateObservable(devtools) {\n    return devtools.state;\n}\nclass StoreDevtoolsModule {\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    static instrument(options = {}) {\n        return {\n            ngModule: StoreDevtoolsModule,\n            providers: [\n                DevtoolsExtension,\n                DevtoolsDispatcher,\n                StoreDevtools,\n                {\n                    provide: INITIAL_OPTIONS,\n                    useValue: options,\n                },\n                {\n                    provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n                    deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n                    useFactory: createIsExtensionOrMonitorPresent,\n                },\n                {\n                    provide: REDUX_DEVTOOLS_EXTENSION,\n                    useFactory: createReduxDevtoolsExtension,\n                },\n                {\n                    provide: STORE_DEVTOOLS_CONFIG,\n                    deps: [INITIAL_OPTIONS],\n                    useFactory: createConfig,\n                },\n                {\n                    provide: StateObservable,\n                    deps: [StoreDevtools],\n                    useFactory: createStateObservable,\n                },\n                {\n                    provide: ReducerManagerDispatcher,\n                    useExisting: DevtoolsDispatcher,\n                },\n            ],\n        };\n    }\n}\nStoreDevtoolsModule.decorators = [\n    { type: NgModule, args: [{},] }\n];\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { INITIAL_OPTIONS as ɵngrx_modules_store_devtools_store_devtools_f, STORE_DEVTOOLS_CONFIG as ɵngrx_modules_store_devtools_store_devtools_e, createConfig as ɵngrx_modules_store_devtools_store_devtools_h, noMonitor as ɵngrx_modules_store_devtools_store_devtools_g, DevtoolsDispatcher as ɵngrx_modules_store_devtools_store_devtools_k, DevtoolsExtension as ɵngrx_modules_store_devtools_store_devtools_j, REDUX_DEVTOOLS_EXTENSION as ɵngrx_modules_store_devtools_store_devtools_i, IS_EXTENSION_OR_MONITOR_PRESENT as ɵngrx_modules_store_devtools_store_devtools_a, createIsExtensionOrMonitorPresent as ɵngrx_modules_store_devtools_store_devtools_b, createReduxDevtoolsExtension as ɵngrx_modules_store_devtools_store_devtools_c, createStateObservable as ɵngrx_modules_store_devtools_store_devtools_d, StoreDevtoolsModule, RECOMPUTE, StoreDevtools, StoreDevtoolsConfig };\n//# sourceMappingURL=store-devtools.js.map\n","export default \"<div class=\\\"container table-responsive\\\">\\n    \\n    <v-table [options]=\\\"tableOptions\\\"></v-table>\\n\\n    <button type=\\\"button\\\" class=\\\"btn btn-primary float-right\\\" [disabled]=\\\"!hasMore\\\" (click)=\\\"loadMore()\\\">Load\\n        More</button>\\n\\n    <div class=\\\"alert alert-dark\\\" *ngIf=\\\"loading$ | async\\\">\\n        Fetching account info\\n    </div>\\n</div>\"","export default \"<div class=\\\"container\\\">\\n    <table class=\\\"table-striped table-hover custom-table\\\">\\n        <thead>\\n            <tr>\\n                <th *ngFor=\\\"let column of options.columns\\\" (click)=\\\"sortHeader(column.value)\\\"\\n                    [ngClass]=\\\"{ 'sorting': isSorting(column.value), 'sorting_asc': isSortAsc(column.value), 'sorting_desc': isSortDesc(column.value) }\\\">\\n                    <span [innerHTML]=\\\"column.name\\\"></span>\\n                </th>\\n            </tr>\\n        </thead>\\n        <tbody>\\n            <tr *ngFor=\\\"let row of (options.records | async)\\\">\\n                <td *ngFor=\\\"let column of options.columns\\\">{{getValue(row, column)}}</td>\\n            </tr>\\n        </tbody>\\n    </table>\\n</div>\"","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { AccountComponent } from './account/account.component';\nimport { RouterModule, Routes } from '@angular/router';\nimport { StoreModule } from '@ngrx/store';\nimport { StoreDevtoolsModule } from '@ngrx/store-devtools';\nimport { metaReducers, reducers } from './state/reducer';\nimport { VTableComponent } from '../common/v-table/v-table.component';\n\nconst routes:Routes = [\n  {\n    path: '', component: AccountComponent \n  }\n]\n\n\n@NgModule({\n  declarations: [AccountComponent,VTableComponent],\n  imports: [\n    CommonModule,\n    RouterModule.forChild(routes),\n    StoreModule.forFeature('accountFeature', reducers, {metaReducers}),    \n\n    StoreDevtoolsModule.instrument()\n  ], \n})\nexport class AccountModule { }\n","export default \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2FjY291bnQvYWNjb3VudC9hY2NvdW50LmNvbXBvbmVudC5jc3MifQ== */\"","import { Component, OnInit } from '@angular/core';\nimport { AccountService } from '../state/account.service';\nimport { Store } from '@ngrx/store';\nimport { AccountInitialState } from '../state/account.states';\nimport * as AccountReducer from '../state/account.reducers';\nimport { Observable, Subscription } from 'rxjs';\nimport { Account, IAccount } from '../state/account.model';\nimport { VTableColumnDefinition } from 'src/app/common/v-table/vtable.model';\n\n@Component({\n  selector: 'app-account',\n  templateUrl: './account.component.html',\n  styleUrls: ['./account.component.css']\n})\nexport class AccountComponent implements OnInit {\n\n  account$: Observable<IAccount[]>\n  loading$: Observable<boolean>\n\n  hasMore: boolean\n  page: number\n\n  tableOptions: Object\n\n  constructor(private accountService: AccountService,\n    private store: Store<AccountInitialState>) {\n\n  }\n\n  ngOnInit() {\n    \n    this.account$ = this.store.select(AccountReducer.getAccountData);\n    this.loading$ = this.store.select(AccountReducer.getLoading);\n\n    this.store.select(AccountReducer.getHasMore).subscribe(data => this.hasMore = data)\n    this.store.select(AccountReducer.getPage).subscribe(data => this.page = data)\n    this.fetchAccountInfo();\n    this.initTableOptions();\n  }\n\n  loadMore() {\n    this.fetchAccountInfo();\n  }\n\n  private fetchAccountInfo() {\n    if (this.hasMore) {\n      this.accountService.get(this.page);\n    }\n  }\n\n  initTableOptions() {\n    var columns : VTableColumnDefinition[] = [\n      { name: 'Account', value: 'account'},\n      { name: 'Change', value: 'change'}      \n    ];\n\n    this.tableOptions = {\n      records: this.account$,\n      columns: columns,\n      config: {\n        sortDirection: \"asc\",\n      },\n    };\n    \n  }\n\n}\n","import * as AccountActions from './account.actions';\r\nimport { AccountInitialState, AppState } from './account.states';\r\nimport { createFeatureSelector, createSelector } from '@ngrx/store';\r\n\r\nexport type Action = AccountActions.All;\r\n\r\nconst accountInitialState: AccountInitialState =  {\r\n    loading: false,\r\n    data: [],\r\n    hasMore: true, \r\n    page: 1\r\n};\r\n\r\nexport function AccountReducer(state = accountInitialState, action: Action): AccountInitialState {\r\n\r\n    switch (action.type) {\r\n        case AccountActions.SET_LOADING:\r\n            return {...state, loading: action.payload}; \r\n\r\n        case AccountActions.ADD:\r\n            return {...state, loading: false, data: [...state.data, ...action.payload]};\r\n\r\n        case AccountActions.UPDATE_NEXT_PAGE:\r\n            return {...state, loading: false, page: action.payload.page, \r\n                    hasMore: action.payload.hasMore};\r\n\r\n        default:\r\n            return state;\r\n    }\r\n\r\n}\r\n\r\n\r\nexport const getAccountState = createFeatureSelector<AppState>('accountFeature');\r\n\r\nexport const getLoading = createSelector(\r\n    getAccountState, \r\n    (state: AppState) => state.accountInitialState.loading\r\n)\r\n\r\nexport const getAccountData = createSelector(\r\n    getAccountState,\r\n    (state: AppState) => state.accountInitialState.data\r\n);\r\n\r\nexport const getHasMore = createSelector(\r\n    getAccountState, \r\n    (state: AppState) => state.accountInitialState.hasMore\r\n)\r\n\r\nexport const getPage = createSelector(\r\n    getAccountState, \r\n    (state: AppState) => state.accountInitialState.page\r\n)\r\n","import { ActionReducerMap, ActionReducer, MetaReducer } from '@ngrx/store';\r\nimport { AppState } from './account.states';\r\nimport * as fromAccountReducer from './account.reducers';\r\n\r\n\r\nexport const reducers: ActionReducerMap<AppState> = {\r\n    accountInitialState: fromAccountReducer.AccountReducer,\r\n};\r\n\r\nexport function logger(reducer: ActionReducer<AppState>): ActionReducer<AppState> {\r\n    return function(state: AppState, action: any): AppState {\r\n      if (action.type === 'clear state') {\r\n        state = undefined;\r\n      }\r\n      console.log('state', state);\r\n      console.log('action', action);\r\n      return reducer(state, action);\r\n    };\r\n}\r\n\r\nexport const metaReducers: MetaReducer<AppState>[] = [logger]; \r\n","export default \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2NvbW1vbi92LXRhYmxlL3YtdGFibGUuY29tcG9uZW50LmNzcyJ9 */\"","import { Component, OnInit, Input } from '@angular/core';\nimport { VTableOptions } from './vtable.model';\nimport { Subscription, Observable } from 'rxjs';\n\n@Component({\n  selector: 'v-table',\n  templateUrl: './v-table.component.html',\n  styleUrls: ['./v-table.component.css']\n})\nexport class VTableComponent implements OnInit {\n\n  @Input() options: VTableOptions;\n  sortedData\n  constructor() { }\n\n  ngOnInit() {\n    this.options.records.subscribe(val => {\n      // deal with asynchronous Observable result\n      this.sortedData = val;\n    })\n  }\n\n  isSorting(name: string) {\n    return this.options.config.sortBy !== name && name !== '';\n  };\n  \n  isSortAsc(name: string) {\n    var isSortAsc: boolean = this.options.config.sortBy === name && \n      this.options.config.sortDirection === 'asc';\n    return isSortAsc;\n  };\n  \n  isSortDesc(name: string) {\n    var isSortDesc: boolean = this.options.config.sortBy === name && \n      this.options.config.sortDirection === 'desc';\n    return isSortDesc;\n  };\n\n  getValue(row, column){\n    return column.value.split('.').reduce((prev:any, curr:string) => prev[curr], row);\n  }\n\n  sortHeader(headerName: string) {\n    if (headerName) {\n      let sortDirection = false\n      if (this.options.config.sortBy === headerName) {\n        this.options.config.sortDirection = this.options.config.sortDirection === 'asc' ? 'desc' : 'asc'\n        sortDirection = this.options.config.sortDirection === 'asc' ? true : false;\n      }\n      this.options.config.sortBy = headerName;\n      this.sort(this.sortedData, this.options.config.sortBy, sortDirection,false);\n    }\n  }\n\n  private sort = (arr,field, reverse, primer) => {\n\n    const key = primer ?\n      function(x) {\n        return primer(x[field])\n      } :\n      function(x) {\n        return x[field]\n      };\n    \n      console.log(\"key\", key)\n  \n    reverse = !reverse ? 1 : -1;\n  \n    return arr.sort(function(a, b) {\n      return a = key(a), b = key(b), reverse * ((a as any > b as any) - (b as any > a as any));\n    })\n  }\n\n\n}\n"],"sourceRoot":"webpack:///"}